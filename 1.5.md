# 1.5 Concetti base di Sistemi Operativi
La maggior parte dei sistemi operativi presenta alcuni concetti di base e astrazioni, quali sono **processi, spazi degli indirizzi e file**.
Essi sono fondamentali per la comprensione del funzionamento del S.O.

# 1.5.1 I Processi
Un concetto chiave di ogni S.O √® quello del **processo**.

>**DEF:** Un processo *√® un programma in esecuzione* che funge anche da ***contenitore** che raccoglie tutte le informazioni necessarie per far girare quel programma*

Associato a ogni processo c'√® il suo **spazio degli indirizzi**, *un elenco di locazioni di memoria da 0 a un massimo*, che il processo pu√≤ leggere e scrivere.

Lo spazio degli indirizzi contiene **il programma eseguibile, i dati del programma e il suo stack**

In molti S.O, *tutta l'informazione riguardante ciascun processo*, diversa dai contenuti del suo spazio degli indirizzi, *√® salvata in una tabella del S.O*, chiamata **tabella del processo**, **che √® un array di strutture**, una per ogni processo in essere.

Un processo (sospeso) consiste quindi del suo spazio degli indirizz, generalmente chiamato **Immagine Core** e del suo elemento nella tabella di processo, *insieme al contenuto dei suoi registri e a molti altri oggetti necessari per avviare il processo successivamente*.

Le chiamate chiave del sistema di gestione del processo sono quelle che hanno a che fare con la creazione e chiusura dei processi.

>**E.g:** 
Un processo chiamato **interprete dei comandi** o **shell** legge i comandi a un terminale. L'utente ha appena digitato un comando con cui richiede la compilaizone di un programma. Quando quel processo ha terminato il suo lavoro, effetuer√† una **chiamata di sistema** o **System Call** per terminare se stesso.

Quindi, se un processo pu√≤ creare uno o pi√π processi (chiamati ***processi figli***) e questi processi a loro volta possono creare dei processi figli (haha, process inception üòÇüíÄ), arriviamo a creare ***una struttura ad albero***. 
I processi relazionati che cooperano per realizzare uno specifico lavoro (E.g: Un videogioco) *necessitano di comunicare l'uno con l'altro e sincronizzare le loro attivit√†/dati*.

Questa comunicazione √® chiamata **Comunicazione tra processi** (***I**nter***P***rocess **C**ommunication*) aka **IPC**

Un processo ha a disposizione altre System Calls ***per richiedere pi√π memoria** (o rilasciare memoria non pi√π usata/necessaria), **attendere un processo figlio** che viene terminato o sovrapporre il suo programma a un altro*

![alt text](https://i.imgur.com/dFJ930m.png)

Inoltre, *ad ogni persona autorizzata* a usare il sistema √® assegnato un **UID** (***U**ser **ID**entification*) dall'amministratore di sistema.

***Ogni processo che parte ha l'UID della persona che lo fa partire***.

***Un processo figlio ha lo stesso UID del padre***.

Gli utenti posso appartenere a dei gruppi, ognuno dei quali ha lo stesso **GID** (***G**roup **ID**entification*)

Un preciso UID, chiamato **Superuser** (in UNIX uwu) o **Administrator** in Windows, ha un potere speciale e pu√≤ violare molte regole della protezione.

&nbsp;
# 1.5.2 Spazi degli Indirizzi
Ogni computer ha una memoria principale impiegata per il mantenimento dei programmi in esecuzione.

Gli S.O pi√π sofisticati consentono a pi√π programmi di essere in memoria allo stesso tempo.

Per evitare che un processo interferisca con l'altro (e con l'S.O) (E.g: Il ***DeadLock***), sono stati implementati *diversi metodi*.

Anche se questi metodi di controllo *dovrebber√≤ risiedere nell'hardware, essi vengono contrallati dall'S.O*.

Inoltre, un problema che affligeva i vecchi calcolatori era **l'uso, la gestione e la protezione della memoria.**
>**E.g:** Se un processo doveva **allocare uno spazio degli indirizzi equivalente a 2^32** (4 Gigabyte) ma il **calcolatore aveva a disposizione solo 4 Gigabyte di Memoria** (RAM), si sarebbe andati in contro a una **situazione di Deadlock**, dato che ***non sarebbe pi√π rimasto spazio in memoria*** per gli altri processi e funzioni fondamentali del S.O

Nei nuovi calcolatori esiste una tecnica denominata **Memoria Virtuale** (in UNIX chiamata **Swap**) che essenzialmente consente al S.O di *prendere una parte dello spazio degli indirzzi in memoria* e *spostarli su un'unit√† di memorizzazione fisica* e ***fissa*** (E.g: SSD o HDD), cosi facendo **liberando memoria**. E quando un processo deve accedere a quello spazio di memoria, *il S.O prende quella parte di spazio degli indirizzi e la ricarica in memoria*.

Questa tecnica per√≤ ha un grave **punto dolente**, ovver√≤ che ***in base al dispositivo di memorizazzione*** (E.g: *Un HDD invece che un SSD*), **il processo di ricaricare quella parte degli indirizzi pu√≤ richiedere un gran tempo**, portando **latenza e rallentamenti**.

&nbsp;
# 1.5.3 File
Un altro concetto fondamentale di un S.O √® il **File System**.

Ovvero quella parte del S.O che
>Nasconde tutte le *informazioni e dati tecnici dei dischi e dispostivi di I/O* e *li presenta al programmatore/utente* in una **forma astratta, gradevole e pulita** in modo da *facilitarne l'uso* (E.g: Cancellare, creare e modificare un documento di testo)

Ovviamente sotto la scocca **sono necessarie delle System Calls** che *eseguono le operazioni richieste*.

Per tenere traccia di tutti i file scritti e presenti sul disco, √® necessario un *sistema di raggruppamento*, che in un S.O √® espresso sottoforma di **Directories** (**Cartelle**)

***Esempio di Cartelle e sottocartelle con file all'interno***
![alt text](https://i.imgur.com/93G5tht.png)

Ogni directory inoltre* pu√≤ essere specificata* tramite il **path name** (**nome di percorso**)

***Esempio di Path Name***:
>`C:\Users\fois2\Desktop\Uni\Libri Uni`

&nbsp;

>***NOTA:*** In UNIX il simbolo per separare le diverse directory nel path name √® il seguente:  ***`/`***

>Mentre su Windows viene usato il simbolo seguente:  ***`\`***


&nbsp;
&nbsp;
&nbsp;

Ogni directory **√® figlia della directory di partenza**, chiamata **root directory (cartella principale)**

***Esempio di Root Directory e le sue Sub Directory in Windows***
    
    C:
        -Programmi
            - *tutte le cartelle di ogni programma installato*
                - *tutti i file di ogni programma installato*
        -Utenti
            -fois2
                -Desktop
                    - *tutti i file presenti nel desktop*
                -Documenti
                    - *tutti i documenti creati dall'Utente*
                - *Altre cartelle*
        -Windows
            - *tutte le cartelle dove risiedono i file essenziali per il funzionamento del S.O*
            - *altri file essenziali*


&nbsp;
&nbsp;
&nbsp;

Prima che un file possa essere letto, deve essere **localizzato sul disco e aperto**, **effettuare** (*se sono presenti*) **le modifiche** e alla fine occorre **chiuderlo**.

Ma prima della scrittura di eventuali modifiche, bisogna controllare i suoi **permessi**.

Se √® consentito l'accesso allora il S.O restituisce un piccolo numero intero chiamato **Descrittore di File (file descriptor)** da usare nelle operazioni di modifica.

Ma **se l'accesso viene proibito**, viene restituito un **codice d'errore** e **nessuna modifica** viene apportata a quel file. 


&nbsp;
&nbsp;
&nbsp;

# **PARTE SOLO UNIX**
In UNIX a differenza di Windows, un **dispostivo di memorizazzione esterno**, come pu√≤ essere un Floppy, CD, DVD, USB e HDD/SSD Esterni, **non viene automaticamente messo a disposizione dell'Utente/Programmatore**.

>***NOTA:*** Nei Sistemi **Linux con una GUI**, questi dispositivi di memorizzazione esterni **vengono automaticamente messi a disposizione** dell'Utente/Programmatore, mentre nei sistemi **solo CLI** (***C**omand **L**ine **I**nterface*) **rimane il funzionamento come sui sistemi UNIX**

Per fare in modo che questi dispotivi vengano messi a disposizione dell'Utente/Programmatore, bisogna prima fare il loro **Mount**.

>***DEF:*** Per **Mount** si definisce un metodo per fornire un'elegante modalit√† di gestione di questi supporti rimovibili. UNIX consente al file system presente del dispostivo removibile di connettersi al file system del sistema.