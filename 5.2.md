# 5.2 Principi del software di I/O


*Obiettivi del Software di I/O*
====

Obiettivi
-   `Indipendenza dal dispositivo`:

    -   Il significato è che dovrebbe essere possibile scrivere programmi che possono accedere a qualsiasi dispositivo di I/O senza dover specificare in anticipo il dispositivo. 

    -   Sta al sistema operativo farsi carico dei problemi causati dal fatto che questi dispositivi siano in realtà diversi e necessitino di sequenze di comandi molto diversi per leggere o per scrivere.

-   `Notazione uniforme`:

    -   È strettamente correlato all’indipendenza dal dispositivo. 

    -   Il nome di un file o di un dispositivo dovrebbe essere semplicemente una stringa o un numero e non dipendere in alcun modo dal dispositivo. 

    -   In UNIX tutti i dischi possono essere integrati nella gerarchia del file system in modo arbitrario, così l’utente non ha bisogno di essere a conoscenza di quale nome corrisponde a quale dispositivo. 

-   `Gestione degli errori`:

    -   In generale gli errori andrebbero gestiti il più possibile a livello hardware.

    -   Se il controller scopre un errore di lettura dovrebbe provare esso stesso a correggerlo, se possibile; altrimenti dovrebbe essere il driver del dispositivo a correggerlo, probabilmente provando a rileggere il blocco.

    -   Solo quando i livelli più bassi non sono in grado di gestire il problema devono essere avvisati i livelli superiori.

    -   In molti casi il recupero dell’errore avviene ai livelli più bassi, senza che i livelli superiori sappiano dell’errore.

-   `Gestione di varie opzioni di trasferimento`:

    -   La maggior parte dell’I/O fisico è asincrono:

        -   La CPU inizia il trasferimento e smette per fare qualsiasi altra cosa finché non arriva un interrupt.

    -   I programmi utente sono molto più semplici da scrivere se le operazioni di I/O sono bloccanti

    -   Sta al sistema operativo fare in modo che operazioni che in realtà sono guidate dagli interrupt sembrino bloccanti al programma utente.

-   `Buffering`:

    -   Spesso i dati che escono da un dispositivo non possono essere memorizzati direttamente nella destinazione finale.

    -   Alcuni dispositivi hanno vincoli real-time stringenti (per esempio i dispositivi audio digitali), per cui i dati devono essere messi anticipatamente in un buffer di output per rendere indipendente la velocità con cui il buffer si riempie dalla velocità con cui si svuota, al fine di evitare il fenomeno detto buffer underrun.

    -   L’uso di un buffer richiede molte operazioni di copia e provoca spesso un impatto pesante sulle prestazioni dell’I/O.


-   `Prestazioni`:

    -   Alcuni dispositivi di I/O, come i dischi, possono essere usati da molti utenti contemporaneamente, causando cali di prestazioni.

    -   Presenza di Deadlock in dispositivi che possono eseguire solo un job alla volta (Es: Stampanti).

    -   Il sistema operativo deve essere in grado di gestire sia i dispositivi condivisi sia quelli dedicati in modo da evitare i problemi.

&nbsp;
&nbsp;
&nbsp;

*I/O Programmato*
====

Il processore manda un comando di I/O e poi attende che l’operazione sia terminata, testando lo stato del dispositivo con un loop `busy-wait` (`polling`).
Efficiente solo se la velocità del dispositivo è paragonabile con
quella della CPU.

Il processore manda un comando di I/O; il processo viene sospeso. 

Quando l’I/O è terminato, un interrupt segnala che i dati sono pronti e il processo può essere ripreso. 

Nel frattempo, la CPU può mandare in esecuzione altri processi o altri thread dello stesso processo.


Vettore di interrupt: tabella che associa ad ogni interrupt l’indirizzo di una corrispondente routine di gestione.

Gli interrupt vengono usati anche per indicare eccezioni (e.g., divisione per zero).

![alt text](https://i.imgur.com/K5PSmYy.png)

&nbsp;
&nbsp;
&nbsp;

*I/O Guidato da Interrupt*
====

Andiamo ora a considerare il caso di una stampa su una stampante che non ha buffer ma stampa un carattere dopo l’altro man mano che arrivano. Se la stampante può stampare per esempio 100 caratteri/s, ogni carattere impiega 10 ms per essere stampato. Ciò significa che dopo l’operazione di scrittura nel registro dei dati della stampante di ciascun carattere, la CPU si fermerà in un ciclo di inattività di 10 ms, in attesa che le sia consentito l’output del carattere successivo. Questo tempo è più che sufficiente per attivare un cambio di contesto ed eseguire qualche altro processo in quei 10 ms che altrimenti andrebbero persi.

Per permettere alla CPU di fare qualcos’altro nell’attesa che la stampante sia pronta è possibile usare gli interrupt. Avvenuta la chiamata di sistema per stampare la stringa, il buffer è copiato nello spazio del kernel, come abbiamo mostrato prima, e il primo carattere è copiato nella stampante appena è in grado di accettarlo. A questo punto la stampante richiama lo scheduler e viene eseguito un altro processo. Il processo che ha richiesto la stampa della stringa è bloccato finché non è stampata l’intera stringa. Il lavoro fatto sulla chiamata di sistema è mostrato nella Figura 5.9(a).



Scrittura di una stringa sulla stampante utilizzando l’I/O guidato dagli interrupt. (a) Codice eseguito nel momento in cui è fatta la chiamata di sistema per la stampa. (b) Procedura di servizio degli interrupt per la stampante.
```
copy_from_user(buffer, p, count);                       if (count == 0) {
enable_interrupts( );                                       unblock_user( );
while (*printer_status_reg != READY);                  } else {
*printer_data_register = p[0];                              *printer_data_register = p[i];
scheduler( );                                               count = count - 1;
                                                            i = i + 1;
                                                        }
                                                        acknowledge_interrupt( );
                                                        return_from_interrupt( );

(a)                                                     (b)
```

Quando la stampante ha stampato il carattere ed è pronta ad accettare il successivo, genera un interrupt. Questo interrupt ferma il processo attuale e salva il suo stato. Poi è eseguita la procedura di servizio dell’interrupt della stampante. Una versione piuttosto grezza di questo codice è mostrata nella Figura 5.9(b). Se non ci sono più caratteri da stampare, il gestore degli interrupt esegue qualche azione per sbloccare l’utente. Altrimenti, esegue l’output del carattere successivo, avvisa l’interrupt e ritorna al processo che stava eseguendo appena prima dell’interrupt, continuandolo da dove era stato lasciato.

&nbsp;
&nbsp;
&nbsp;

*I/O con DMA*
====

Uno svantaggio ovvio dell’I/O guidato dagli interrupt è che avviene un interrupt a ogni carattere. Gli interrupt richiedono tempo, pertanto questo schema spreca una certa quantità di tem­po CPU. Una soluzione è l’uso del DMA. In questo caso l’idea è di lasciare che il controller DMA invii i caratteri alla stampante uno alla volta, senza disturbare la CPU. In sostanza, il DMA è I/O programmato, con solo il controller DMA che fa tutto il lavoro, invece del­la CPU principale. Questa strategia richiede sì un hardware speciale (il controller DMA), ma lascia che la CPU faccia altre cose durante l’I/O. Uno schema sommario del codice è dato nella Figura 5.10. Il successo del DMA consiste nella riduzione del numero degli interrupt da uno per carattere a uno per buffer stampato. Nel caso di numerosi caratteri e interrupt lenti, si tratta di un grande miglioramento. Dall’altra parte il controller DMA è generalmente molto più lento della CPU principale. Se il controller DMA non è in grado di condurre il dispositivo a velocità massima o se la CPU non ha comunque nulla da fare mentre è in attesa ­dell’interrupt del DMA, allora potrebbe andar meglio l’I/O gestito dagli interrupt o anche l’I/O program­mato. La maggior parte delle volte vale la pena usare il DMA.


Stampa di una stringa usando il DMA. (a) Codice eseguito nel momento in cui è fatta la chiamata di sistema per la stampa. (b) Procedura di servizio degli interrupt.

```
copy_from_user(buffer, p, count);                       acknowledge_interrupt( );

set_up_DMA_controller( );                               unblock_user( );

scheduler( );                                           return_from_interrupt( );

(a)  
```      